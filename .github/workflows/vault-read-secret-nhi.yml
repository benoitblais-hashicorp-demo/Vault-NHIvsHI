# This workflow is manually triggered via `workflow_dispatch`.
#
# It uses direct `curl` calls to authenticate against an HCP Vault cluster using
# a short-lived GitHub OIDC token via Vault's JWT auth method, read a secret from
# a KV v2 secrets engine, and print each key/value pair in plaintext in the job
# output. This is intended as a demonstration of Non-Human Identity (NHI) access
# to Vault secrets from GitHub Actions.
#
# The OIDC token is kept in a bash variable within a single step and never
# written to GITHUB_OUTPUT — this prevents GitHub from redacting it as `***`
# when it is referenced across steps after masking. The OIDC token and Vault
# token are masked with `::add-mask::`. The secret payload is never registered
# as a masked value, so all key/value pairs are printed in plaintext using a
# `jq to_entries[]` loop.
#
# Prerequisites:
# - The workflow must have `id-token: write` permission to request an OIDC token.
# - A Vault JWT auth method mounted at the path specified by `auth_path` input,
#   configured with `bound_audiences` matching the `jwt_audience` input.
#
# Documentation
# - https://developer.hashicorp.com/vault/docs/auth/jwt
# - https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect
#

name: Vault – Read KV v2 Secret (Non-Human Identity)

on:  # yamllint disable-line rule:truthy
  workflow_dispatch:
    inputs:
      vault_address:
        description: "HCP Vault cluster URL without trailing slash (e.g. https://<id>.vault.hashicorp.cloud:8200)"
        required: true
        type: string
      vault_namespace:
        description: "Vault namespace (e.g. admin/nhivshi-demo)"
        required: true
        type: string
      kv_mount:
        description: "KV v2 mount path (e.g. secret)"
        required: true
        type: string
      secret_path:
        description: "Path to the secret within the KV v2 mount (e.g. demo/nhi-credentials)"
        required: true
        type: string
      auth_path:
        description: "Mount path of the JWT auth method (e.g. jwt_github)"
        required: true
        type: string
      vault_role:
        description: "Vault role to use for authentication (e.g. jwt_github_role)"
        required: true
        type: string
      jwt_audience:
        description: "Audience claim on the OIDC token — must match bound_audiences in the Vault JWT role (e.g. https://vault.hashicorp.cloud)"
        required: true
        type: string

permissions:
  contents: read
  id-token: write  # Required for GitHub Actions to request an OIDC token for JWT auth

jobs:
  read-vault-secret:
    name: Read KV v2 Secret (Non-Human Identity – GitHub OIDC JWT)
    runs-on: ubuntu-latest
    steps:

      - name: Request OIDC Token, Login to Vault and Retrieve Secret
        env:
          VAULT_ADDR: ${{ inputs.vault_address }}
          VAULT_NAMESPACE: ${{ inputs.vault_namespace }}
        run: |
          # Strip any trailing slash from VAULT_ADDR to prevent double-slash URLs
          VAULT_ADDR="${VAULT_ADDR%/}"

          # Request a short-lived GitHub OIDC token — kept in a bash variable,
          # never written to GITHUB_OUTPUT, so masking does not redact it in later steps
          OIDC_RESPONSE=$(curl -sS \
            --header "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${{ inputs.jwt_audience }}")
          OIDC_TOKEN=$(echo "$OIDC_RESPONSE" | jq -r '.value // empty')
          if [[ -z "$OIDC_TOKEN" ]]; then
            echo "ERROR: Failed to obtain OIDC token. Raw response:"
            echo "$OIDC_RESPONSE"
            exit 1
          fi
          echo "::add-mask::$OIDC_TOKEN"

          # Exchange the GitHub OIDC token for a Vault token via JWT auth
          VAULT_LOGIN_URL="$VAULT_ADDR/v1/auth/${{ inputs.auth_path }}/login"
          echo "Attempting Vault JWT login at: $VAULT_LOGIN_URL"
          echo "  namespace : $VAULT_NAMESPACE"
          echo "  role      : ${{ inputs.vault_role }}"
          CURL_STDERR=$(mktemp)
          VAULT_RESPONSE=$(curl -sS \
            --header "X-Vault-Namespace: $VAULT_NAMESPACE" \
            --request POST \
            --data "{\"jwt\": \"$OIDC_TOKEN\", \"role\": \"${{ inputs.vault_role }}\"}" \
            "$VAULT_LOGIN_URL" 2>"$CURL_STDERR")
          CURL_EXIT=$?
          VAULT_TOKEN=$(echo "$VAULT_RESPONSE" | jq -r '.auth.client_token // empty')
          if [[ -z "$VAULT_TOKEN" ]]; then
            echo "ERROR: Failed to obtain Vault token (curl exit: $CURL_EXIT)"
            if [[ -s "$CURL_STDERR" ]]; then
              echo "curl error output:"
              cat "$CURL_STDERR"
            fi
            echo "Raw Vault response:"
            echo "$VAULT_RESPONSE"
            exit 1
          fi
          echo "::add-mask::$VAULT_TOKEN"

          # Read the secret from KV v2 and iterate over every key/value pair
          # Nothing is registered with ::add-mask:: so all values print in plaintext
          SECRET_RESPONSE=$(curl -sS \
            --header "X-Vault-Token: $VAULT_TOKEN" \
            --header "X-Vault-Namespace: $VAULT_NAMESPACE" \
            "$VAULT_ADDR/v1/${{ inputs.kv_mount }}/data/${{ inputs.secret_path }}")
          SECRET_DATA=$(echo "$SECRET_RESPONSE" | jq -r '.data.data // empty')
          if [[ -z "$SECRET_DATA" ]]; then
            echo "ERROR: Failed to retrieve secret. Raw response:"
            echo "$SECRET_RESPONSE"
            exit 1
          fi

          echo "Secret data retrieved from ${{ inputs.kv_mount }}/data/${{ inputs.secret_path }}:"
          echo "$SECRET_DATA" | jq -r 'to_entries[] | "  \(.key) = \(.value)"'
